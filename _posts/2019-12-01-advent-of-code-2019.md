---
categories: advent-of-code haskell
date:   2019-12-01
layout: post
title:  "The Advent of Code 2019 Haskell adventure"
---

This year I've decided to try my hand at the [Advent of Code](https://adventofcode.com)!
I've decided to use it as an opportunity to learn Haskell and share notes on what I've learnt while doing it so it sticks better.

I might not make it through the whole Advent but as long as I'll learn something new, it will already be a huge success for me! : )

# Day 1: The Tyranny of the Rocket Equation 

The first puzzle was quite simple to solve, even though not being that familiar with Haskell 
environment it took me some time to figure out how to set up the most basic working Stack project.
From the initial skeleton `src/` and `test/` directories are not needed
(unless you're planning to write unit tests which will be useful for more tricky puzzles).
All comments and most properties can be removed from both `package.yaml` and `stack.yaml` files for clarity.

When it comes to Haskell itself, I've already learnt a lot:

- the difference between float (`(/)`) and integer (`div`, `quot`) division
- how to read command line arguments in program (`System.Environment.getArgs` FTW)
- `reduce` and `fold` mean exactly the same
- the difference between:
    - `foldr`: combine the first element of the list with the result of applying the function to the rest of the list, so in some funky hybrid of C/Haskell notation: `f a[0] (f a[1] (f a[2] (f a[3] k)))`
    - `foldl`: combine the result of applying the function to the whole list except from the last element with that last element, so using the same notation: `f (f (f (f k a[0]) a[1]) a[2]) a[3]`

    where `f` is the function to be "folded" and `k` is an initial value. The order of `foldl` and `foldr` arguments is different!

My code solving day 1 puzzle is available [here](https://github.com/mjarosie/advent-of-code-2019/tree/master/day-1).

# Day 2: 1202 Program Alarm

Even though my understanding of functional programming is still quite shallow, because of pattern matching this day's puzzle sounded like a problem that Haskell shines in solving. I got a much better grasp of the concept. Yes, there's a difference between a tuple of elements and a list of elements!

I'm still struggling with the application of `($)` function, but hopefully when I try applying it more and more it will finally click.
For example I had problems understanding the difference between (notice no `($)` in `f'`):

```haskell
f :: [Int] -> Int -> [Int]
f xs i = drop i . take (i + 4) $ xs -- sublist of elements from i to i + 4
```

AND

```haskell
f' :: [Int] -> Int -> [Int]
f' xs i = drop i . take (i + 4) xs -- sublist of elements from i to i + 4
```

`f'` will not even compile because of a type mismatch.

Finally, I had a first encounter with the most basic Haskell debugging tool: `Debug.Trace.trace`!

It always reminds me of this graphic (for non-Polish speakers, DUPA stands for [Data User Password Authentication](https://www.wykop.pl/wpis/8245694/dupa-debugging-kazdy-pewnie-z-nas-przynajmniej-raz/)):

![printf DUPA driven development](/assets/2019-12-01-advent-of-code-2019/debugging.jpg)

I've also run into the monomorphism restriction, which turns out to be a [counter-intuitive rule in Haskell type inference](https://wiki.haskell.org/Monomorphism_restriction). I encountered it while debugging - it dissappeared as quickly as it showed up. I'll have to bump into it at least a few more times to understand it better.

For the second part I've mainly struggled with changing my way of thinking about the program - I wanted to refrain from using the equivalent of `for` loop. I've used recursion instead, which feels like a more Haskellish way to do things.

My code solving day 2 puzzle is available [here](https://github.com/mjarosie/advent-of-code-2019/tree/master/day-2).